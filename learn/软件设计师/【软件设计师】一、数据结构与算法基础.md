占比：13.33%

---

# 操作系统

## 位示图

位示图（bitmap）的作用是记录磁盘**物理块**的使用情况。

# 线性结构

## 线性表

一个线性表是$n(n \geq 0)$个元素的有限序列，通常表示为（$a_1, a_2, ..., a_n$）。

### 存储结构

#### 顺序存储

##### 元素位置

一般地，以$LOC(a_1)$表示线性表中第一个元素的存储位置，在顺序存储结构中，第$i$个元素$a_i$的存储位置为：
$$
LOC(a_i) = LOC(a_1)+(i-1) \times L
$$
其中，$L$是表中每个数据元素所占空间的字节数。

在表长为$n$的线性表中插入一个新元素需要移动元素个数的期望值$E_{insert}$为：
$$
E_{insert}
= \displaystyle \sum^{n+1}_{i=1}P_i \times (n-i+1)
= {\frac{1}{n+1}} \displaystyle \sum^{n+1}_{i=1}(n-i+1)
= \frac n 2
$$
其中，$P_i$表示在表中位置$i$插入新元素的概率。

在表长为$n$的线性表中删除一个元素需要移动元素个数的期望值$E_{delete}$为：
$$
E_{delete}
= \displaystyle \sum^n_{i=1}q_i \times (n-i)
= {\frac{1} n} \displaystyle \sum^n_{i=1}(n-i)
= \frac {n-1} 2
$$
其中，$q_i$表示删除第$i$个元素的概率。



#### 链式存储

在实际应用中，为了简化对链表状态的判定和处理，特别引入一个不存储数据元素的结点，称为头结点，将作为链表的第一个结点并令头指针指向该结点。

## 栈和队列

### 栈

栈是只能通过访问它的一端来实现数据存储和检索的一种线性数据结构。

### 队列

队列是一种先进先出的线性表它只允许在表的一端（队尾）插入元素，而在表的另外i一端（队头）删除元素。，

### 串

串（字符串）是一种特殊的线性表，其数据元素为字符。

#### 串的模式匹配

1. 朴素的模式匹配
2. 改进的模式匹配（KMP）

## 数组、矩阵和广义表

# 树

## 树的属性

- **节点的层次性**：树是按层级构建的，根节点位于最顶层，而叶子节点位于最底层。每个节点的所有子节点与另一个节点的所有子节点无关，且叶子节点都是独一无二的。
- **节点的度**：结点拥有的子树个数称为结点的度。度为0的称为叶结点，度不为0的称为分支结点。树的度是树内各个节点的度的最大值。
- **树的高度**：树的高度是其中节点层数的最大值，即从根节点到最远叶子节点的最长路径上的节点数。
- **树的类型**：根据不同的标准，树可以分为多种类型。例如，根据每个节点最多有两个子节点，可以将树称为二叉树。此外，树还可以根据其子树是否有序分为有序树和无序树。有序树中，子树的排列顺序是重要的；而在无序树中，子树的排列顺序可以互换。
- **树的递归定义**：任何一个树都可以被看作是由一个根结点和若干不相交的子树组成的，因此树是一种递归定义的数据结构。
- **树的属性特征**：包括结点的层次（深度）、结点的高度、树的高度（深度）、结点的度、树的度等。这些属性共同描述了树的结构和特性。
- **树的性质**：如结点数等于总度数加1（因为根结点没有计算在内），以及度为m的树和m叉树的区别等。这些性质帮助理解树的特性和如何计算特定属性。

## 树的分类

1. 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树。
2. 有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树。
3. 二叉树：每个节点最多含有两个子树的树称为二叉树。
4. 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树。
5. 完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树。
6. **平衡二叉树**：（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
7. 哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。



## 树的遍历

根据**根节点**的遍历顺序将遍历顺序分为三种：

先序：根、左、右。

中序：左、根、右。

后序：左、右、根。

# 图

1. 无向图：边没有方向的图称为无向图。
2. 连通图：

## 甘特图

# 排序算法

## 内排序

内排序也称为内部排序，是指待排的记录全部在内存中完成排序的过程。若待排序记录的数量庞大，在排序的过程中需要使用到外部存储介质如磁盘等，这种涉及内外存储器数据交换的排序过程称为外部排序，又称为**外排序**。

### 交换排序

#### 冒泡排序

每趟扫描都会找出一个最大的数沉降到最最底端。[百度百科](https://vd3.bdstatic.com/mda-mcepjfagnaymjf99/hd/mda-mcepjfagnaymjf99.mp4)。

![img](https://img-blog.csdnimg.cn/20190329112514534.gif)

#### 快速排序

是冒泡排序的一种改进。每次选择一个未排序的数据（一般是从左边开始依次进行）进行排序，将该选定的值作为**基准**，然后从两端进行依次向中间扫描，并和基准值进行比较，如果是升序排序，则比基准值大的移动到右边，比基准值小的移动到左边，每当完成一次扫描就确定了该基准值的位置。然后递归对该基准值左右部分重复使用上述规则即可。

![img](https://img2020.cnblogs.com/blog/696190/202004/696190-20200429164722256-464828495.gif)

#### 选择排序

第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

![选择排序](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

### 插入排序

#### 直接插入排序

插入排序是一种最简单的[排序](https://baike.baidu.com/item/排序/1066239?fromModule=lemma_inlink)方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。注意：进行元素比较时，是从已排序的末尾逐个向前比较，而不是从前向后比较的。

![img](https://img-blog.csdnimg.cn/20200302231043451.gif)

#### 希尔排序

希尔排序是插入排序的一个升级版，它主要是将原先的数据分成若干个子序列，然后将每个子序列进行插入排序，然后每次拆得子序列数量逐次递减，直到拆的子序列的长度等于原数据长度。然后再将数据整体来依次插入排序。

主要步骤：

1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
2. 按增量序列个数 k，对序列进行 k 趟排序；
3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

原始未排序的数据。
![img](https://img-blog.csdnimg.cn/2021030822304116.png)
经过初始增量`gap=array.length/2=5`分组后，将原数据分为了5组，[12,1]、[29,30]、[5,45]、[16,26]、[15,32]。
![img](https://img-blog.csdnimg.cn/20210308223122579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70)
将分组后的数据，每一组数据都直接执行插入排序，这样数据已经慢慢有序起来了，然后再缩小增量`gap=5/2=2`，将数据分为2组：[1,5,15,30,26]、[29,16,12,45,32]。
![img](https://img-blog.csdnimg.cn/20210308223302714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70)
对上面已经分好的两组进行插入排序，整个数据就更加趋向有序了，然后再缩小增量`gap=2/2=1`，整个数据成为了1组，整个序列作为了表来处理，然后再执行一次插入排序，数据最终达到了有序。
![最后一次插入排序](https://img-blog.csdnimg.cn/20210308225836617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70)

### 归并排序

先递归拆分，然后合并。每次合并的两个序列一定是排好序的，这样就不会反复循环进行比较。

![img](https://img-blog.csdnimg.cn/20210314130157798.gif#pic_center)

### 堆排序

# 查找算法

## 贪心法

在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。
贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。

### 算法思路

贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，其选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。

贪心算法一般按如下步骤进行：

1. 建立数学模型来描述问题 。
2. 把求解的问题分成若干个子问题。
3. 对每个子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

# 典型问题

## 背包问题

### 分数背包问题

给定 $𝑛$ 个物品，第 $𝑖$ 个物品的重量为 $𝑤𝑔𝑡[𝑖−1]$、价值为 $𝑣𝑎𝑙[𝑖−1]$ ，和一个容量为 $𝑐𝑎𝑝$ 的背包。每个物品只能选择一次，**但可以选择物品的一部分，价值根据选择的重量比例计算**，问在限定背包容量下背包中物品的最大价值。

### 0-1 背包问题

给定 $𝑛$ 个物品，第 $𝑖$ 个物品的重量为 $𝑤𝑔𝑡[𝑖−1]$、价值为 $𝑣𝑎𝑙[𝑖−1]$ ，和一个容量为 $𝑐𝑎𝑝$ 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

### 完全背包问题

### 多重背包问题

## 旅行商问题

## 最长公共子序列



# 参考

- [Hello 算法](https://www.hello-algo.com/)
- [Java实现十个经典排序算法（带动态效果图） ](https://www.cnblogs.com/jimoer/p/14532184.html)


